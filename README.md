# Библиотечная система

API для управления библиотекой, включающее функционал для работы с книгами, читателями и библиотекарями.

## Структура проекта

> Для данного приложения была выбрана модульная структура, поскольку она упрощает навигацию по проекту и обеспечивает масштабируемость

```
src/
|-- books/           # Модуль для работы с книгами
|   |-- dao.py       # Data Access Object для книг
|   |-- models.py    # SQLAlchemy модели
|   |-- router.py    # FastAPI роутер
|   |-- schemas.py   # Pydantic схемы
|   |-- service.py   # Бизнес-логика
|-- core/            # Ядро приложения
|   |-- dao.py       # Файл с базовым Data Access Object
|   |-- config.py    # Конфигурация
|   |-- database.py  # Настройки БД
|   |-- security.py  # Безопасность и JWT
|-- librarians/      # Модуль для работы с библиотекарями
|-- readers/         # Модуль для работы с читателями
|-- main.py          # Точка входа
```

## Запуск проекта

### Вариант 1: Запуск через Docker Compose

1. Убедитесь, что у вас установлены Docker (и Docker Compose, если используете старую версию Docker, в таком случае замените все `docker compose` на `docker-compose`)
2. Клонируйте репозиторий и перейдите в директорию проекта

```bash
git clone https://github.com/umerenkovmaksim/patres-test-task.git
cd patres-test-task
```

3. Создайте файл `.env` в корневой директории проекта со следующим настройками:

```
DEBUG=True # Режим отладки
# ---------------
DB_NAME=library # Имя базы данных
DB_USER=postgres # Пользователь базы данных
DB_PASSWORD=postgres # Пароль пользователя
# ---------------
SECRET_KEY="secret_key" # Секретный ключ для JWT
ACCESS_TOKEN_EXPIRE_MINUTES=20 # Время жизни токена доступа в минутах
```

4. Запустите приложение из директории docker:

```bash
cd docker
docker compose up --build -d
```

5. Примените миграции

```bash
docker compose exec -it backend uv run alembic upgrade head
```

Приложение будет доступно по адресу: http://localhost:8000

### Вариант 2: Ручной запуск

1. Убедитесь, что у вас установлен Python 3.12
2. Клонируйте репозиторий и перейдите в директорию проекта
3. Создайте и активируйте виртуальное окружение:

```bash
python3 -m venv .venv
source .venv/bin/activate  # для Linux/Mac
# или
.venv\Scripts\activate  # для Windows
```

4. Установите зависимости:

```bash
pip install uv
uv sync
```

5. Установите и запустите PostgreSQL

6. Создайте файл `.env` в корневой директории проекта с содержимым из примера с запуском через Docker Compose. Также следует добавить следующие строчки с информацией о хосте с базой данных:

```bash
DB_HOST=localhost # Хост базы данных
DB_PORT=5432 # Порт базы данных
```

7. Примените миграции:

```bash
uv run alembic upgrade head
```

8. Запустите приложение:

```bash
uv run uvicorn src.main:app --reload
```

Приложение будет доступно по адресу: http://localhost:8000

## Документация API

После запуска приложения, документация API будет доступна по следующим адресам:

- Swagger UI: http://localhost:8000/docs
- ReDoc: http://localhost:8000/redoc

## Регистрация первого пользователя

1. Запустите приложение
2. Откройте Swagger UI по адресу `http://localhost:8000/docs` (или http://localhost:8000/redoc)
3. Используйте эндпоинт `POST /librarians/register` для создания первого библиотекаря
4. После регистрации используйте `POST /librarians/login` для получения JWT токена

## Структура базы данных

### Основные таблицы:

- `books` - информация о книгах (название, автор, год, ISBN, количество копий)
- `readers` - информация о читателях
- `librarians` - информация о библиотекарях
- `borrowed_books` - записи о выдаче книг

### Связи:

- `borrowed_books` связана с `books` и `readers` через внешние ключи
- Каждая книга может быть выдана нескольким читателям (через `borrowed_books`)
- Каждый читатель может взять несколько книг (через `borrowed_books`)

## Бизнес-логика

### 1. Выдача книг

- Реализовано в `BookService.borrow_book`
- Все изменения и проверки связанные с таблицами `books`, `readers` и `borrowed_books` происходят при помощи DAO (Data Access Objects) данных модулей
- Проверки:
  - Существование книги и читателя
  - Наличие свободных копий
  - Лимит на количество книг у читателя - проверяется через количество записей в таблице `borrowed_books` с `reader_id` читателя, которому выдается книга

### 2. Возврат книг

- Реализовано в `BookService.return_book`
- Все изменения и проверки осуществляются также при помощи DAO
- Проверки:
  - Существование записи о выдаче
  - Книга еще не возвращена

## Аутентификация

### Реализация

- Используется JWT (JSON Web Tokens) для аутентификации
- Библиотека: `python-jose[cryptography]` для работы с JWT
- Хеширование паролей: `passlib[bcrypt]`
- При успешной аутентификации генерируется access token
- Токен содержит:
  - ID пользователя
  - Время истечения

### Генерация JWT

- Токен генерируется в `create_access_token()`:
  - Принимает словарь с данными и время жизни токена
  - Добавляет время истечения (exp)
  - Подписывается секретным ключом через алгоритм HS256
  - Возвращает закодированный JWT

### Проверка JWT

- Проверка происходит в `get_cur_librarian()`:
  - Извлекает токен из заголовка Authorization
  - Декодирует токен используя секретный ключ
  - Проверяет подпись и время истечения
  - Извлекает ID пользователя из payload
  - Проверяет существование пользователя в БД
  - Возвращает объект пользователя или ошибку

### Защищенные эндпоинты

- Все эндпоинты, кроме:
  - `GET /books` (публичный список книг)
  - `POST /librarians/register` (регистрация)
  - `POST /librarians/login` (аутентификация)

### Почему JWT?

- Не требует хранения сессий на сервере
- Масштабируемость - можно легко добавить новые сервисы
- Безопасность - токены подписываются секретным ключом

## Предлагаемая дополнительная фича: Система бронирования книг

Позволяет читателям бронировать книги, которые сейчас недоступны (когда все копии выданы).

### Реализация

1. Новая таблица `book_reservations`:

   - ID бронирования
   - ID книги
   - ID читателя
   - Дата бронирования
   - Статус (active/cancelled/fulfilled)

2. Бизнес-логика:

   - Читатель может забронировать книгу
   - При возврате книги система проверяет наличие броней
   - Уведомление первого читателя в очереди
   - Автоматическая отмена брони через определенное время

3. API эндпоинты:

   - `POST /books/{id}/reserve` - создать бронь
   - `GET /books/{id}/reservations` - список броней
   - `DELETE /books/{id}/reserve` - отменить бронь

## Бонусная фича

Также можно переписать структуру проекта на использование единой модели `User` с различными ролями

### Преимущества

1. Объединение общего функционала - не нужно будет дублировать код схожих функций для каждой модели отдельно
2. Возможность легкого добавления других ролей, вместо создания отдельной модели
3. Упрощение разработки и тестирования функционала связанного с пользователями
